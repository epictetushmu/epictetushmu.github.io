import{y as m,l as V,z as P,g as b,A as U}from"./index-BpKRf9zd.js";const z={REQUIRED:"This field is required",EMAIL:"Please enter a valid email address",MIN_LENGTH:"Must be at least {min} characters long",MATCH:"Values do not match"},Q={EMAIL:/^[^\s@]+@[^\s@]+\.[^\s@]+$/};class T{constructor(t=!0,s=[]){this.isValid=t,this.errors=s}addError(t,s){this.isValid=!1,this.errors.push({field:t,message:s})}getErrorsForField(t){return this.errors.filter(s=>s.field===t)}getFirstErrorForField(t){const s=this.getErrorsForField(t);return s.length>0?s[0].message:null}hasErrors(){return this.errors.length>0}clear(){this.isValid=!0,this.errors=[]}}class q{constructor(){this.rules=new Map,this.customValidators=new Map}addRule(t,s){this.rules.set(t,s)}addCustomValidator(t,s){this.customValidators.set(t,s)}validateField(t,s){const l=new T,d=this.rules.get(t)||[],u=this.customValidators.get(t);for(const a of d){const o=a(s,t);o&&l.addError(t,o)}if(u){const a=u(s,t);a&&l.addError(t,a)}return l}validateForm(t){const s=new T;for(const[l,d]of Object.entries(t)){const u=this.validateField(l,d);u.isValid||s.errors.push(...u.errors)}return s.isValid=s.errors.length===0,s}clearRules(){this.rules.clear(),this.customValidators.clear()}}const O=new q;function X(i={},t={},s={}){const{validateOnChange:l=!0,validateOnBlur:d=!0,debounceMs:u=300}=s,a=m({...i}),o=m({}),n=m({}),h=V(!1),f=V(!0),c=V(!1);Object.entries(t).forEach(([e,r])=>{O.addRule(e,r)});let v=null;const I=e=>{v&&clearTimeout(v),v=setTimeout(()=>{E(e)},u)},E=e=>{const r=O.validateField(e,a[e]);return o[e]=r.getErrorsForField(e).map(F=>F.message),r.isValid},p=()=>{const e=O.validateForm(a);return Object.keys(o).forEach(r=>delete o[r]),e.errors.forEach(r=>{o[r.field]||(o[r.field]=[]),o[r.field].push(r.message)}),f.value=e.isValid,e.isValid},M=e=>{var r;return((r=o[e])==null?void 0:r[0])||null},A=e=>o[e]&&o[e].length>0,w=e=>n[e]||!1,j=e=>{n[e]=!0},k=e=>{o[e]&&delete o[e]},g=()=>{Object.keys(o).forEach(e=>delete o[e]),f.value=!0},C=()=>{Object.keys(a).forEach(e=>{a[e]=i[e]||""}),g(),Object.keys(n).forEach(e=>delete n[e]),c.value=!1},L=e=>{Object.assign(a,e),c.value=!0},R=(e,r)=>{a[e]=r,c.value=!0,l&&I(e)},S=(e,r)=>{R(e,r.target.value)},D=e=>{j(e),d&&E(e)},H=async e=>{if(!h.value){if(Object.keys(a).forEach(r=>{n[r]=!0}),!p())return{success:!1,errors:o};h.value=!0,g();try{return{success:!0,data:await e(a)}}catch(r){return{success:!1,error:U.handle(r,{formData:a})}}finally{h.value=!1}}};P(a,(e,r)=>{const F=Object.keys(e).some(y=>e[y]!==(i[y]||""));c.value=F},{deep:!0});const _=b(()=>f.value&&!h.value&&c.value),B=b(()=>Object.keys(o).length>0),G=b(()=>Object.values(o).reduce((e,r)=>e+((r==null?void 0:r.length)||0),0));return{formData:a,errors:o,touched:n,isSubmitting:h,isValid:f,isDirty:c,canSubmit:_,hasErrors:B,errorCount:G,validateField:E,validateForm:p,getFieldError:M,hasFieldError:A,isFieldTouched:w,touchField:j,clearFieldError:k,clearErrors:g,resetForm:C,updateFormData:L,setFieldValue:R,handleFieldInput:S,handleFieldBlur:D,handleSubmit:H}}export{Q as R,z as V,X as u};
