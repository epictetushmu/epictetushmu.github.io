import{x as R,r as D,y as k,j as V,z as q}from"./index-q9JKsn7m.js";const f={REQUIRED:"This field is required",EMAIL:"Please enter a valid email address",MIN_LENGTH:"Must be at least {min} characters long",MAX_LENGTH:"Must be no more than {max} characters long",PASSWORD_STRENGTH:"Password must contain at least 8 characters, including uppercase, lowercase, number, and special character",PHONE:"Please enter a valid phone number",URL:"Please enter a valid URL",MATCH:"Values do not match"},p={EMAIL:/^[^\s@]+@[^\s@]+\.[^\s@]+$/,PHONE:/^[\+]?[1-9][\d]{0,15}$/,URL:/^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/,PASSWORD_STRONG:/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/};class w{constructor(t=!0,e=[]){this.isValid=t,this.errors=e}addError(t,e){this.isValid=!1,this.errors.push({field:t,message:e})}getErrorsForField(t){return this.errors.filter(e=>e.field===t)}getFirstErrorForField(t){const e=this.getErrorsForField(t);return e.length>0?e[0].message:null}hasErrors(){return this.errors.length>0}clear(){this.isValid=!0,this.errors=[]}}class u{static required(t,e="Field"){return t==null||t===""?`${e} is required`:null}static email(t){return t?p.EMAIL.test(t)?null:f.EMAIL:null}static minLength(t,e,i="Field"){return t&&t.length<e?f.MIN_LENGTH.replace("{min}",e):null}static maxLength(t,e,i="Field"){return t&&t.length>e?f.MAX_LENGTH.replace("{max}",e):null}static passwordStrength(t){return t?p.PASSWORD_STRONG.test(t)?null:f.PASSWORD_STRENGTH:null}static phone(t){return t?p.PHONE.test(t.replace(/\s/g,""))?null:f.PHONE:null}static url(t){return t?p.URL.test(t)?null:f.URL:null}static number(t,e="Field"){return t==null||t===""?null:isNaN(t)?`${e} must be a valid number`:null}static positiveNumber(t,e="Field"){const i=this.number(t,e);return i||(parseFloat(t)<=0?`${e} must be a positive number`:null)}static date(t,e="Date"){if(!t)return null;const i=new Date(t);return isNaN(i.getTime())?`${e} must be a valid date`:null}static futureDate(t,e="Date"){const i=this.date(t,e);return i||(new Date(t)<=new Date?`${e} must be in the future`:null)}static pastDate(t,e="Date"){const i=this.date(t,e);return i||(new Date(t)>=new Date?`${e} must be in the past`:null)}static match(t,e,i="Fields"){return t!==e?`${i} do not match`:null}static oneOf(t,e,i="Field"){return e.includes(t)?null:`${i} must be one of: ${e.join(", ")}`}static pattern(t,e,i){return t?e.test(t)?null:i:null}}class Z{constructor(){this.rules=new Map,this.customValidators=new Map}addRule(t,e){this.rules.set(t,e)}addCustomValidator(t,e){this.customValidators.set(t,e)}validateField(t,e){const i=new w,l=this.rules.get(t)||[],o=this.customValidators.get(t);for(const s of l){let n=null;s.required?n=u.required(e,t):s.email?n=u.email(e):s.minLength?n=u.minLength(e,s.minLength,t):s.maxLength?n=u.maxLength(e,s.maxLength,t):s.passwordStrength?n=u.passwordStrength(e):s.phone?n=u.phone(e):s.url?n=u.url(e):s.number?n=u.number(e,t):s.positiveNumber?n=u.positiveNumber(e,t):s.date?n=u.date(e,t):s.futureDate?n=u.futureDate(e,t):s.pastDate?n=u.pastDate(e,t):s.match?console.warn(`'match' validation rule for field '${t}' cannot be automatically applied in generic loop. Consider using a custom validator.`):s.oneOf?n=u.oneOf(e,s.oneOf,t):s.pattern&&(n=u.pattern(e,s.pattern,s.message)),n&&i.addError(t,n)}if(o){const s=o(e,t);s&&i.addError(t,s)}return i}validateForm(t){const e=new w;for(const[i,l]of Object.entries(t)){const o=this.validateField(i,l);o.isValid||e.errors.push(...o.errors)}return e.isValid=e.errors.length===0,e}clearRules(){this.rules.clear(),this.customValidators.clear()}}const L=new Z;function X(c={},t={},e={}){const{validateOnChange:i=!0,validateOnBlur:l=!0,debounceMs:o=300}=e,s=R({...c}),n=R({}),d=R({}),m=D(!1),b=D(!0),h=D(!1);Object.entries(t).forEach(([r,a])=>{L.addRule(r,a)});let E=null;const $=r=>{E&&clearTimeout(E),E=setTimeout(()=>{F(r)},o)},F=r=>{const a=L.validateField(r,s[r]);return n[r]=a.getErrorsForField(r).map(g=>g.message),a.isValid},S=()=>{const r=L.validateForm(s);return Object.keys(n).forEach(a=>delete n[a]),r.errors.forEach(a=>{n[a.field]||(n[a.field]=[]),n[a.field].push(a.message)}),b.value=r.isValid,r.isValid},v=r=>{var a;return((a=n[r])==null?void 0:a[0])||null},M=r=>n[r]&&n[r].length>0,P=r=>d[r]||!1,T=r=>{d[r]=!0},H=r=>{n[r]&&delete n[r]},O=()=>{Object.keys(n).forEach(r=>delete n[r]),b.value=!0},I=()=>{Object.keys(s).forEach(r=>{s[r]=c[r]||""}),O(),Object.keys(d).forEach(r=>delete d[r]),h.value=!1},_=r=>{Object.assign(s,r),h.value=!0},A=(r,a)=>{s[r]=a,h.value=!0,i&&$(r)},y=(r,a)=>{A(r,a.target.value)},G=r=>{T(r),l&&F(r)},x=async r=>{if(!m.value){if(Object.keys(s).forEach(a=>{d[a]=!0}),!S())return{success:!1,errors:n};m.value=!0,O();try{return{success:!0,data:await r(s)}}catch(a){return{success:!1,error:q.handle(a,{formData:s})}}finally{m.value=!1}}};k(s,(r,a)=>{const g=Object.keys(r).some(j=>r[j]!==(c[j]||""));h.value=g},{deep:!0});const C=V(()=>b.value&&!m.value&&h.value),U=V(()=>Object.keys(n).length>0),z=V(()=>Object.values(n).reduce((r,a)=>r+((a==null?void 0:a.length)||0),0));return{formData:s,errors:n,touched:d,isSubmitting:m,isValid:b,isDirty:h,canSubmit:C,hasErrors:U,errorCount:z,validateField:F,validateForm:S,getFieldError:v,hasFieldError:M,isFieldTouched:P,touchField:T,clearFieldError:H,clearErrors:O,resetForm:I,updateFormData:_,setFieldValue:A,handleFieldInput:y,handleFieldBlur:G,handleSubmit:x}}export{p as R,f as V,X as u};
